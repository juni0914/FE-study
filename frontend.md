# Front-End CS

<br>

<h1> 1. Promise</h1>

### 🌟 정의 🌟
<h4>
	
- Promise 객체는 JavaScript에서 비동기 작업을 처리하기 위한 내장 객체로, 비동기 작업의 완료 여부와 결과를 나타내는 객체다. <br><br>

1. 대기(Pending): 초기 상태로, 작업이 완료되지 않았을 때의 상태다.<br><br>

2. 이행(Fulfilled): 비동기 작업이 성공적으로 완료되었을 때의 상태다. 이때 Promise가 성공 상태로 전환되며 작업의 결과를 가지고 있다.<br><br>

3. 거부(Rejected): 비동기 작업이 실패했을 때의 상태다. Promise가 실패 상태로 전환되며 에러 정보를 가지고 있다.<br><br>
</h4>
<br>

### 🌈 예시 코드 🌈

```
// Promise를 생성합니다.
const myPromise = new Promise((resolve, reject) => {
  // 비동기 작업을 수행합니다. (예: 네트워크 요청)
  const success = true; // 비동기 작업의 결과 (성공 여부)

  if (success) {
    // 작업이 성공한 경우
    resolve("성공했습니다."); // resolve 함수를 호출하여 Promise를 이행합니다.
  } else {
    // 작업이 실패한 경우
    reject("실패했습니다."); // reject 함수를 호출하여 Promise를 거부합니다.
  }
});

// Promise를 사용합니다.
myPromise
  .then((result) => {
    console.log("성공:", result); // 작업이 성공한 경우
  })
  .catch((error) => {
    console.error("실패:", error); // 작업이 실패한 경우
  });

```
### ⛅ 설명 ⛅
<h4>
	
1. Promise 객체는 new Promise()를 사용하여 생성된다. 이 객체는 콜백 함수를 인자로 받으며, 비동기 작업을 수행하고 결과를 resolve 또는 reject 함수를 호출하여 처리한다.<br><br>
2. then 메서드는 Promise가 성공적으로 완료됐을 때 실행할 콜백 함수를 등록한다.<br><br>
3. catch 메서드는 Promise가 거부됐을 때 실행할 콜백 함수를 등록한다.<br><br><br><br>

🔥 Promise를 사용하면 비동기 작업을 보다 효율적으로 처리하고, 더 직관적으로 코드를 작성할 수 있다. <br><br>이를 통해 콜백 지옥과 같은 문제를 해결하고 코드를 더 읽기 쉽게 만들 수 있다.
</h4>
<br>
<br>

<br>

<h1> 2. 브라우저 저장소</h1>

### 🌟 정의 🌟
<h4>
	
- 웹 브라우저 저장소는 웹 애플리케이션 및 웹사이트에서 데이터를 저장하고 검색할 수 있는 방법을 제공하는 중요한 웹 기술이다.<br><br>
- 이 저장소는 사용자 경험을 향상시키고 웹 애플리케이션의 성능을 개선하기 위해 사용된다. <br><br>
- 주요한 웹 브라우저 저장소 유형으로는 쿠키, 웹 스토리지, 웹 데이터베이스, IndexedDB 및 캐시가 있다. <br><br>
</h4>

<h2>1. 쿠키(Cookies)</h2>
<h4>
- 쿠키는 작은 텍스트 파일로, 웹 사이트에서 사용자의 브라우저에 저장된다.<br><br>
- 주로 세션 관리, 사용자 식별, 사용자 설정 저장 등에 사용된다.<br><br>
- 쿠키는 제한된 용량을 가지며, 주로 문자열 형태로 데이터를 저장한다.<br><br>
</h4><br>

<h2>2. 웹 스토리지(Web Storage)</h2>
<h4>
- 웹 스토리지는 브라우저 내에 데이터를 저장하는 데 사용된다. 두 가지 주요 유형이 있다.<br><br>
- 로컬 스토리지(Local Storage) : 데이터가 영구적으로 저장되며 도메인 내의 모든 페이지에서 접근할 수 있다.<br><br>
- 세션 스토리지(Session Storage) : 데이터가 세션 동안만 저장되며 브라우저 세션 종료 시 삭제된다.<br><br>
</h4><br>

<h2>3. 웹 데이터베이스(Web Database)</h2>
<h4>
- 웹 데이터베이스는 클라이언트 측에서 구조화된 데이터를 저장하는 데 사용된다.<br><br>
- 이전에는 웹 SQL 데이터베이스라고도 불렸으며 SQL 쿼리를 사용하여 데이터를 조작할 수 있었다.<br><br> 
- 그러나 이 기술은 오래된 것으로 간주되고 지원이 중단됐다.<br><br>

</h4><br>
<br>

<h2>4. IndexedDB </h2>
<h4>
- IndexedDB는 복잡한 구조화된 데이터를 저장하고 검색하는 데 사용되는 클라이언트 측 데이터베이스다.<br><br>
- 비동기 API를 사용하여 데이터를 처리하며 대량의 데이터를 효율적으로 다룰 수 있다.<br><br>
</h4><br>
<br>

<h2>5.캐시(Cache) </h2>
<h4>
- 브라우저는 이미 방문한 웹 페이지의 자원(이미지, 스크립트, 스타일 시트 등)을 캐시하여<br><br> 다시 다운로드하지 않고 빠르게 로드할 수 있도록 도와준다.<br><br>
</h4><br>
<br>

### ⛅ 설명 ⛅
<h4>
🔥 웹 브라우저 저장소를 사용하면 웹 애플리케이션은 데이터를 저장하고 오프라인 작업을 지원하며 사용자 설정 및 기타 정보를 유지할 수 있다.<br><br>
이러한 저장소 유형은 웹 개발자가 다양한 상황에서 데이터를 효율적으로 관리하고 사용자에게 더 나은 웹 경험을 제공하는 데 도움을 준다.
</h4>
<br>
<br>

<h1> 3. TCP와 UDP</h1>

### 🌟 정의 🌟
<h4>
	
- TCP (Transmission Control Protocol)와 UDP (User Datagram Protocol)는 둘 다 컴퓨터 네트워크에서<br><br>
- 데이터 통신을 위한 프로토콜로, 전송 계층(Transport Layer)에서 작동한다. <br><br>

</h4>
<br>

![image](https://github.com/juni0914/React-study/assets/100837725/81f6bb9c-b537-4e11-ab23-0586b19e13ca)



<h2>TCP (Transmission Control Protocol)</h2>
<h4><br><br>

1. 연결 지향성 (Connection-Oriented): TCP는 연결 지향적인 프로토콜로, 데이터를 전송하기 전에 연결을 설정하고, 데이터를 안전하게 전송한 후에 연결을 해제한다.<br><br>


2. 신뢰성 (Reliability): TCP는 데이터 전송의 신뢰성을 중요시한다. 손실된 패킷을 재전송하고, 순서를 보장하여 데이터의 신뢰성을 확보한다.<br><br>


3. 흐름 제어 (Flow Control): TCP는 데이터의 흐름을 관리하고 과부하를 방지하기 위한 흐름 제어 메커니즘을 제공한다.<br><br>


4. 에러 검출 및 복구 (Error Detection and Correction): TCP는 에러를 검출하고 복구하기 위한 메커니즘을 가지며, 데이터의 완전성을 보장한다.<br><br>


5. 높은 오버헤드: TCP 헤더에는 연결 관리 및 신뢰성을 위한 추가 정보가 포함되므로 오버헤드가 크다.<br><br>


6. 사용 사례: 웹 브라우징, 파일 전송 (FTP), 이메일 (SMTP, POP3), 웹 서버 (HTTP)와 같이 데이터 신뢰성이 중요한 어플리케이션에서 사용된다.<br><br>

</h4>


<h2>UDP (User Datagram Protocol)</h2>
<h4><br><br>
	
1. 비연결성 (Connectionless): UDP는 비연결성 프로토콜로, 데이터를 전송할 때 연결을 설정하거나 해제하지 않는다.<br><br>

2. 비신뢰성 (Unreliable): UDP는 데이터 패킷의 신뢰성을 보장하지 않다. 데이터 손실이나 순서 변경이 발생할 수 있다.<br><br>

3. 빠른 전송 (Fast Transmission): UDP는 데이터를 빠르게 전송하기 위해 효율적인 프로토콜로 설계되었다.<br><br>

4. 낮은 오버헤드: UDP 헤더에는 TCP보다 적은 오버헤드가 포함되며, 이는 데이터를 빠르게 전송하는 데 도움이 된다.<br><br>

5. 사용 사례: 음성 통화 (VoIP), 비디오 스트리밍, 게임 서버, DNS 서비스 및 실시간 데이터 스트리밍과 같이 데이터 레이턴시가 더 중요한 어플리케이션에서 사용된다.<br><br><br><br>
- ✔ 이러한 차이로 인해 TCP는 데이터 신뢰성이 중요한 어플리케이션에 적합하며, UDP는 실시간 데이터 전송이 필요한 곳에 적합하다.<br><br>
 선택은 어플리케이션의 요구사항과 데이터 전달의 중요성에 따라 달라진다.
</h4>
<br>
<br>


<h1> 4. 웹 브라우저 동작 방식</h1>

### 🌟 브라우저의 정의 🌟
<h4>
	
- 웹 브라우저는 동기(Synchronous)적으로 (HTML + CSS), Javascript 언어를 해석하여 내용을 화면에 보여주는 응용 소프트웨어다.<br><br>
- 웹 브라우저가 웹 서버에 필요한 자원(웹 페이지)을 요청하면 서버는 응답하고 웹 브라우저는 이를 해석한 후 사용자(Client)에게 보여준다.<br><br>
- 보통 자원은 HTML 문서지만 PDF, 이미지 등 다양한 형태일 수 있다. <br><br>
- 웹 브라우저의 종류는 다양합니다. 크롬, 네이버 웨일, 파이어폭스, 사파리 등이 대표적인 예다. <br><br>

</h4>

### 🚩 브라우저의 구조 🚩
<br><br>
![image](https://github.com/juni0914/FE-study/assets/100837725/ef027c41-16d3-43dc-9053-784461126f2e)
<br>

<h2>1. 사용자 인터페이스 </h2>
<h4>
-  사용자가 접근할 수 있는 영역입니다. URI를 입력할 수 있는 주소 표시줄, 이전/다음 버튼, 북마크 메뉴, 새로 고침 버튼과 <br><br>
현재 문서의 로드를 중단할 수 있는 정지 버튼 , 홈 버튼 등 요청한 페이지를 보여주는 창을 제외한 나머지 모든 부분이다.<br><br>
</h4>

<h2>2. 브라우저 엔진 </h2>
<h4>
- 사용자 인터페이스와 렌더링 엔진 사이의 동작을 제어한다. Data Storage를 참조하며 로컬에 데이터를 쓰고 읽으면서 다양한 작업을 한다. <br><br>
</h4>

<h2>3. 렌더링 엔진 </h2>
<h4>
- 웹 서버로부터 응답 받은 자원을 웹 브라우저 상에 나타낸다. 예를 들어 HTML 문서를 응답받으면 HTML과 CSS를 파싱 하여 화면에 표시한다. <br><br>
브라우저의 동작 원리를 이해하려면 렌더링 엔진의 이해가 중요하다. <br><br>
- 브라우저는 서버로부터 HTML 문서를 응답받으면 렌더링 엔진의 HTML 파서와 CSS 파서에 의해 파싱(parsing)되어<br><br>
DOM, CSSOM 트리로 변환되고 렌더 트리로 결합한다. 이렇게 생성된 렌더 트리를 기반으로 브라우저는 웹 페이지를 나타낸다.<br><br>
</h4>

<h2>4. 통신</h2>
<h4>
- HTTP 요청과 같은, 서버와 통신이 가능하게 하는 네트워크 호출에 사용된다.<br><br>
</h4>

<h2>5. UI 백엔드 </h2>
<h4>
- select, input 등 기본적인 위젯을 그리는 인터페이스다.<br><br>
</h4>

<h2>6. 자바스크립트 해석기</h2>
<h4>
-  자바스크립트 코드를 해석하고 실행한다.<br><br>
</h4>

<h2>7. 자료 저장소</h2>
<h4>
-  Cookie, Local Storage, Indexed DB 등 브라우저 메모리를 활용하여 저장하는 영역이다.<br><br>
</h4>

### ⛅ 렌더링 엔진 ⛅
<br><br>
<h4>
- 렌더링 엔진은 HTML, XML, 이미지 등 요청받은 내용을 브라우저 화면에 표시하는 엔진이다.<br><br>
- 렌더링 엔진은 좀 더 나은 사용자 경험을 위해 가능하면 빠르게 내용을 표시한다. <br><br>
- 그래서 일련의 과정들이 동기적으로 진행되지 않는다. HTML을 파싱 할 때까지 기다리지 않고 렌더 트리 배치와 그리기 과정을 시작한다.   <br><br>
</h4>

### ⭐ 렌더링 엔진 동작 과정 ⭐
<br><br>
![image](https://github.com/juni0914/FE-study/assets/100837725/b99de250-be54-463c-a217-d070dfce8138)
<br><br>
<h4>
	
- ① 렌더링 엔진은 HTML 문서를 파싱 하여 DOM 트리를 구축한다. <br><br>

- ② 그다음 외부 CSS 파일과 함께 포함된  스타일 요소를 파싱한다. <br><br>

- ③ DOM 트리와 ②의 결과물을 합쳐 렌더 트리를 구축한다.  <br><br>

- ④ 렌더 트리 각 노드에 대해 화면 상에서 배치할 곳을 결정한다. <br><br> 

- ⑤ UI 백엔드에서 렌더 트리의 각 노드를 그린다. <br><br>

</h4>

### ⭐ 웹킷 엔진 동작 과정 ⭐
<br><br>
![image](https://github.com/juni0914/FE-study/assets/100837725/fc060336-9d31-4229-ad2e-61fbcc1a4b0b)
<h4>
	
- ① HTML 문서를 파싱 하여 DOM(Document Object Model) 트리를 구축한다. <br><br>
 브라우저는 서버로부터 HTML 문서를 모두 전달받고 HTML 파서를 통하여 파싱(parsing)하고 파싱 트리를 생성한다. <br><br>
생성된 파싱 트리를 기반으로 DOM 트리를 생성한다.<br><br>

- ② CSSOM(Css Object Model)을 생성한다. <br><br>
 CSS 파일은 스타일 시트 객체로 파싱 되고 각 객체는 CSS 규칙을 포함한다.  <br><br>
 CSS 규칙 객체(CSSOM)는 선택자와 선언 객체 그리고 CSS 문법과 일치하는 다른 객체를 포함한다.<br><br>

- ③ 렌더 트리(DOM + CSSOM)를 생성한다.  <br><br>
DOM 트리가 구축되는 동안 브라우저는 DOM 트리를 기반으로 렌더 트리를 생성한다. <br><br>
렌더 트리는 문서를 시각적인 구성 요소로 만들어주는 역할을 한다. <br><br>

- ④ 렌더 트리를 배치한다. (레이아웃)<br><br> 
 렌더 트리는 위치와 크기를 가지고 있지 않기 때문에, 어느 공간에 위치해야 할지 <br><br>
각 객체들에게 위치(position)와 크기(size)를 결정해준다. <br><br>

- ⑤ 렌더 트리를 그린다. <br><br>
렌더 트리가 만들어져 레이아웃이 구성되었으면 UI 백엔드가 동작하여 렌더 트리의 각 객체를 화면의 픽셀(px) 값으로 나타낸다.<br><br>

🔥 지금까지는 HTML 문서를 파싣하여 HTML과 CSS를 렌더링 엔진에서 처리하는 과정이었다. 
</h4>

### 🎯 자바스크립트의 경우 🎯
<h4>
- 자바스크립트는 렌더링 엔진에서 처리가 되지 않는다. <br><br>
- 자바스크립트는 자바스크립트 엔진이 처리한다. HTML 파서는 <script> 태그를 만나면 Javascript 코드를 실행하기 위해<br><br>
DOM 생성 프로세스를 중지하고 자바스크립트 엔진으로 권한을 넘긴다.<br><br>
- 제어 권한을 넘겨받은 자바스크립트 엔진은 <script> 태그 내의 Javascript 코드 또는 src 속성에 정의된 Javascript 파일을 로드하고 파싱 하여 실행한다.<br><br>
- Javascript의 실행이 완료되면 다시 HTML 파서로 제어 권한을 넘겨서 중지했던 시점으로 돌아가 DOM 생성을 재개한다.  <br><br>
</h4>
	
![image](https://github.com/juni0914/FE-study/assets/100837725/8fdbd9fb-6d2e-46a4-a36b-335ba107759f)

<br>
<h1> 5. 클로저(Closure)</h1>

### 🌟 정의 🌟
<h4>
	
- 함수가 선언될(생성될) 그 당시에 주변의 환경과 함께 갇히는 것을 말한다. <br><br>
- 또 다른 말로 설명하면, 함수가 속한 렉시컬 스코프(Lexical Environment)를 기억하여,<br><br>
 함수가 렉시컬 스코프 밖에서 실행될 때도 이 스코프에 접근할 수 있게 해주는 기능이다. <br><br>

 - 렉시컬 스코프란 함수가 선언이 되는 위치에 따라서 상위 스코프가 결정되는 스코프다. 함수가 선언이 될 때, 스코프가 생성된다. <br><br>
</h4>

![image](https://github.com/juni0914/FE-study/assets/100837725/7a412db4-de5d-462d-8e48-986952bf5b06)


### 🎈 예시 🎈

```
function sayHello () {
  const a = 'Hello';
  const b = 'World';
  
  function sumString () {
    console.log(a + ' ' + b);
  }
  
  return sumString;
}

const myFunc = sayHello();

myFunc(); // 'Hello World'
```
### ⛅ 설명 ⛅
<h4>
	
1. myFunc라는 변수는 sayHello 함수를 호출하고 있다. 그래서 myFunc를 실행하게 되면 어떠한 문제 없이 Hello World가 잘 출력된다. <br><br>
2. 여기서 살펴볼 점은 myFunc의 부분은 변수 a와 b가 담겨 있는 sayHello 함수 스코프의 바깥에 있는데도 불구하고 a와 b를 합친 Hello World를 잘 출력한다는 것이다.<br><br>

 
- 그 이유가 바로 클로저(Closure) 때문이다. 모든 자바스크립트 함수는 선언(생성)될 당시에 클로저가 형성되어 주변 환경, 즉 렉시컬 스코프를 기억할 수 있게 되는 것이다.<br><br>
- 이러한 저장소 유형은 웹 개발자가 다양한 상황에서 데이터를 효율적으로 관리하고 사용자에게 더 나은 웹 경험을 제공하는 데 도움을 준다.
</h4>
<br>

### 🎨 장점 🎨
<h4>
	
1. 데이터를 보존할 수 있다.<br><br>
클로저 함수는 외부 함수의 실행이 끝나더라도 외부 함수 내 변수를 사용할 수 있다.<br><br>
클로저는 이처럼 특정 데이터를 스코프 안에 가두어 둔 채로 계속 사용할 수 있게하는 폐쇄성을 갖는다.<br><br>

2. 정보의 접근 제한 (캡슐화)<br><br>
‘클로저 모듈 패턴’을 사용해 객체에 담아 여러 개의 함수를 리턴하도록 만든다.<br><br>
이러한 정보의 접근을 제한하는 것을 캡슐화라고 한다.<br><br>

3. 모듈화에 유리하다.<br><br>
클로저 함수를 각각의 변수에 할당하면 각자 독립적으로 값을 사용하고 보존할 수 있다.<br><br>
이와 같이 함수의 재사용성을 극대화 함수 하나를 독립적인 부품의 형태로 분리하는 것을 모듈화라고한다.<br><br>

- 클로저를 통해 데이터와 메소드를 묶어다닐 수 있기에 클로저는 모듈화에 유리하다. <br><br>

</h4>
<br>
<h1> 6. 웹 렌더링의 방식(SSR, CSR, SSG)</h1>

### 🌟 정의 🌟
<h4>
	
- HTML, CSS, JS 등 개발자가 작성한 문서들을 서버에서 응답받아 브라우저가 화면에 그려주는 동작이다. <br><br>

- 브라우저는 렌더링을 하기 위해 각각의 렌더링 엔진을 가지고 있다. <br><br>

- 각각 브라우저마다 해당 엔진의 종류는 다를 수 있다.<br><br>

</h4>

## 🌈 Server Side Rendering(SSR) 🌈

![image](https://github.com/juni0914/FE-study/assets/100837725/693688f9-4304-410d-bb58-f26640c10a8c)



<h4>

- 브라우저가 서버에 요청하면 서버가 필요한 데이터로 HTML을 구성하여 브라우저에 전송하고 브라우저에서 응답받은 HTML을 렌더링하는 방식이다.<br><br>

- 렌더링이 준비된 HTML 파일을 브라우저에서 로드하기 때문에 첫 페이지 로딩이 빨라지는 이점이 있다.<br><br>

- 이미 만들어진 페이지를 검색엔진 크롤러가 요청에대한 응답을 받기 때문에 SEO에 친화적이다.<br><br>

- 서버에서 매번 페이지를 새로 렌더링하기 때문에 화면이 부드럽지 않는다.<br>
(페이지 이동할때마다 새로고침 현상)<br><br>

- 또한 위 사항 때문에 서버 부하가 생길 수 있으며, 서버 비용 또한 많이 든다.<br><br>

 
</h4>

## ⛅ Client Side Rendering(CSR) ⛅

![image](https://github.com/juni0914/FE-study/assets/100837725/2a4028a8-0935-4f90-a49e-0e317602e7f9)



<h4>
	
- 클라이언트(브라우저) 사이드에서 렌더링을 책임지는 방식 이다.<br><br>

- 최초의 HTML파일을 받는 것을 제외하고 페이지 렌더링을 위한 별도의 HTTP 통신을 할 필요가 없다.<br><br>

- 따라서 서버의 요청없이 클라이언트에서 라우팅을 담당하기 때문에 후속 페이지 로드 시간이 훨신 빠르고 부드럽다.<br><br>

- 서버는 오직 Ajax를 통해 필요한 데이터를 주고 받는 역할만 수행한다.<br><br>

- 자바스크립트의 번들의 크기의 영향을 많이 받기 때문에 코드분할을 고려해야한다.<br><br>

- 브라우저에서 HTML을 컴파일하기 전에 기본 HTML, CSS 및 모든 필수 스크립트를 <br>로드하기 때문에 초기 페이지 로드 시간이 SSR에 비해 느리다.<br><br>

- 검색 엔진 크롤러가 페이지를 처음 방문했을때 빈 페이지기 때문에 SEO에 친화적이지 않다.<br><br>

</h4>

<h2> 

⭐ CSR의 장점은 SSR의 단점이고 CSR의 단점은 SSR의 장점이다.<br><br>
⭐ 이러한 딜레마를 완전하게 해결하지 못하지만 두 방식의 가운데에 해당하는 렌더링 방식이 SSG다.<br><br>

</h2>

## 🌷 Static Site Generator(SSG) 🌷

![image](https://github.com/juni0914/FE-study/assets/100837725/5a4fb22b-634d-453d-a4a4-c7a534541ad6)


<h4>
	
- SSR처럼 서버로부터 HTML을 받아오지만 HTML 파일 생성시점이 빌드타임이다.<br><br>

- 위 처럼 화면을 서버에서 미리 만들어서 전송해주는 기법이다.<br><br>

- 이미 생성된 HTML을 받기 때문에 SEO 친화적이다.<br><br>

- 모든 URL에 대해 개별 HTML 파일을 생성해야 하는 단점이 있다.<br><br>

</h4>


<h1> 7. 이벤트 버블링 / 캡처링</h1>



<h2>1. 이벤트 버블링(Event Bubbling)</h2>

<h4>
	
 ### 🌟 정의 🌟
 
- 이벤트 버블링이란 한 요소에 이벤트가 발생하면 이 요소에 할당된 핸들러가 동작하고,<br><br>
이어서 부모 요소의 핸들러가 동작하고 최상단의 부모 요소를 만날 때까지 반복되면서 핸들러가 동작하는 현상을 말한다.<br><br>
- 대부분의 웹 브라우저에서는 이벤트 버블링이 기본 동작이며, 대부분의 경우에는 이 방식으로 충분하다.<br><br> 그러나 필요한 경우 이벤트 캡처링을 사용하여 이벤트 전파를 더 세부적으로 제어할 수 있다. <br><br> 
	
![image](https://github.com/juni0914/FE-study/assets/100837725/67de329b-ebe7-418a-989f-dbdf2e1ea188)

### 과정

- 이벤트가 발생한 요소부터 시작해서 DOM 트리의 상위 요소로 이벤트가 전파된다. <br><br>
- 즉, 이벤트가 발생한 요소부터 부모, 그 다음 더 상위의 부모 요소로 이벤트가 전파되고, 최종적으로 window 객체까지 전파된다.<br><br>
- 이벤트 버블링은 이벤트 핸들러가 가장 특정한 요소부터 가장 일반적인 요소까지 차례로 처리된다.<br><br>
- 따라서 가장 내부의 요소에서부터 가장 바깥의 요소로 이벤트 핸들링이 이루어진다.
</h4><br>

### 중단하기

<h4>
	
- 이벤트 버블링은 타깃 이벤트에서 시작해서 html 요소를 거쳐 document 객체를 만날 때까지 각 노드에서 모두 발생한다.<br><br>
- 몇몇 이벤트는 window 객체까지 거슬러 올라가기도 한다. 이 때도 모든 핸들러가 호출된다.<br><br>

- 그런데 핸들러에게 이벤트를 완전히 처리하고 난 후 버블링을 중단하도록 명령할 수도 있다.<br><br>

- 이벤트 객체의 메서드인 event.stopPropagation()를 사용하면 된다.<br><br>

- 아래 예시에서 button을 클릭해도 body.onclick은 동작하지 않는다.<br><br>

</h4><br>

```

<body onclick="alert(`버블링은 여기까지 도달하지 못합니다.`)">
  <button onclick="event.stopPropagation()">클릭해 주세요.</button>
</body>

```
<br><br>

<h2>2. 이벤트 캡처링(Event Capturing)</h2>
<h4>

  ### 🌟 정의 🌟
- 캡처링은 버블링과는 반대로 최상위 태그에서 해당 태그를 찾아 내려간다.<br><br>

 ![image](https://github.com/juni0914/FE-study/assets/100837725/6345f94c-0e75-4ca5-94a9-2740f76f6c95)
 
 </h4><br>
 
### 과정

<h4>
	
- 이벤트 캡처링은 이벤트가 window에서부터 시작해서 이벤트가 발생한 요소 방향으로 전파된다.<br><br>
즉, 이벤트가 window에서 시작해서 이벤트가 발생한 요소까지 전파되고, 그 후에 이벤트 버블링 단계로 이벤트가 전파된다.<br><br>
이벤트 캡처링은 이벤트 핸들러가 가장 일반적인 요소에서부터 가장 특정한 요소까지 차례로 처리된다.<br><br>

</h4><br>



<br>
<br>
